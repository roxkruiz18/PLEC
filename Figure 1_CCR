## Load packages

library(RColorBrewer)
library(gProfileR)
library(dplyr)
library(ggplot2)
library(ggrepel)
library(ggpubr)
library(TCGAbiolinks)
library(SummarizedExperiment)
library(survival)
library(survminer)
library(limma)
library(edgeR)
library(DESeq2)

##load data from tcgabiolinks

GDCprojects = getGDCprojects()
#https://docs.gdc.cancer.gov/Data_Portal/Users_Guide/Projects/

##---------------------------------obtain clinical data---------------------------------------##
## if you need extended clinical data this has the various


query <- GDCquery(project = "TCGA-PAAD",
                  data.category = "Clinical",
                  data.type = "Clinical Supplement",
                  data.format = "BCR Biotab")
GDCdownload(query)
clinical.BCRtab.all <- GDCprepare(query)


names(clinical.BCRtab.all)
#[1] "clinical_drug_paad"               "clinical_patient_paad"            "clinical_omf_v4.0_paad"           "clinical_follow_up_v4.4_paad"    
#[5] "clinical_nte_paad"                "clinical_radiation_paad"          "clinical_follow_up_v4.4_nte_paad"

##update this with whatever clinical data you want from the last command:
clinical.BCRtab.all$clinical_drug_paad  %>%
  
  as.data.frame ->clinical
##---------------------------------------------------------------------------------------------##


# Download STAR Counts
query_TCGA = GDCquery(
  project = "TCGA-PAAD",
  data.category = "Transcriptome Profiling", # parameter enforced by GDCquery
  experimental.strategy = "RNA-Seq",
  workflow.type = "STAR - Counts",
  sample.type = c("Primary Tumor"),
  data.type = "Gene Expression Quantification")


##Next, we need to download the files from the query
GDCdownload(query = query_TCGA)
#summarzed vs not summarized is kind of important, check both
tcga_data = GDCprepare(query_TCGA,
                       save = TRUE,
                       summarizedExperiment = TRUE,
                       save.filename = "paad_Illumina_STAR_NORMALS_SUMMARIZEDEXP.rds")
mrna = assay(tcga_data) #raw counts
write.table(mrna, "tcga_paad_count_matrix_mrna.txt", sep='\t')

as.data.frame(colData(tcga_data)) -> coldata_tcga_data


#get patient info that you are most interested in
coldata_tcga_data %>% dplyr::select("patient", "bcr_patient_barcode",
                                    "vital_status",
                                    "days_to_death",
                                    "days_to_last_follow_up",
                                    "gender", "race","ethnicity", "ajcc_pathologic_stage", "ajcc_pathologic_t", 
                                    "ajcc_pathologic_n", "ajcc_pathologic_m", "age_at_index"
                                    
) -> coldata_tcga_data2


mrna_t <- as.data.frame(t(mrna))
mrna_t$ID <- row.names(mrna_t)

coldata_tcga_data2$ID <- row.names(coldata_tcga_data2)


combined_PAAD <- left_join(mrna_t, coldata_tcga_data2, by = c("ID" = "ID"), copy = TRUE)
head(combined_PAAD)

#make rownames the patient ID
row.names(combined_PAAD) <- combined_PAAD$ID


write.csv(combined_PAAD, "TCGA_PAAD-subseted_with_clinical.csv")

###-------------------------Use DESeq2 to get Normalized Count Data----------------------------###

library(DESeq2)

#make a samples dataframe 
#here, we are looking at the gene PLEC (ENSG00000178209.16)
samples <- combined_PAAD %>% dplyr::select(ENSG00000178209.16)

ddsMat <- DESeqDataSetFromMatrix(countData = mrna,
                                 colData = samples,
                                 design = ~1)
dds <- ddsMat

##remove low counts (removing 10 here)
keep <- rowSums(counts(dds) >= 10) >= 22
dds <- dds[keep,]


##use intercept as reference
dds$quartiles <- relevel(dds$quartiles, ref = 1)
dds <- DESeq(dds)
res <- results(dds, )
summary(res)

#variance stabilize
vsd <- vst(dds, blind=FALSE)

resultsNames(dds)

#perform log fold change shrinkage
#Here we are using apeglm
resLFC <- lfcShrink(dds, coef=1, type="apeglm")
#using 'apeglm' for LFC shrinkage. If used in published research, please cite:
#Zhu, A., Ibrahim, J.G., Love, M.I. (2018) Heavy-tailed prior distributions for
#sequence count data: removing the noise and preserving large differences.
#Bioinformatics. https://doi.org/10.1093/bioinformatics/bty895

#save original
resOHT <- res
# SmallestPvalue
idx <- which.min(res$pvalue)
counts(dds)[idx, ]
counts(dds, normalized=TRUE)[idx, ]

##------Once we get normalized counts, we want to split PLEC counts into quartiles

counts_df <- as.data.frame(counts(dds, normalized = TRUE))

PLEC_counts_df <- counts_df[rownames(counts_df) == "ENSG00000178209.16", , drop = FALSE]

# Transpose the dataframe so that samples are rows and counts are columns
PLEC_counts_df <- t(PLEC_counts_df)

# Convert it back to a dataframe with sample IDs as rownames
PLEC_counts_df <- as.data.frame(PLEC_counts_df)

# Add sample IDs as rownames
rownames(PLEC_counts_df) <- colnames(counts_df)

# Calculate the quartiles (including the min and max values)
breaks <- quantile(PLEC_counts_df$ENSG00000178209.16, probs = c(0, 0.25, 0.5, 0.75, 1))

# Create a new column 'Quartile' in the dataframe that assigns quartile based on these breaks
PLEC_counts_df$quartile <- cut(PLEC_counts_df$ENSG00000178209.16, breaks = breaks, include.lowest = TRUE, labels = c("Q1", "Q2", "Q3", "Q4"))


# create the boxplots in Figure 1A
library(scales)
bp <- ggplot(PLEC_counts_df, aes(x=quartile, y=ENSG00000178209.16, fill=quartile)) + 
  geom_boxplot() + theme_classic() + labs(x = "PLEC Quartile", y = "Normalized Count") + 
  theme(plot.title = element_text(hjust = 0.5)) + theme (plot.title = element_text(face = "bold", size = 10)) + 
  theme(axis.title = element_text(size = 12, face = "bold")) + 
  theme(axis.title.x = element_text(size = 9, face = 2), axis.title.y = element_text(size = 9, face = 2)) + 
  theme(axis.line = element_line(size = 0.5)) + 
  theme(axis.text.x = element_text(size=8, face = 1, color = "gray10"),axis.text.y = element_text(size = 8, face = 1, color = "gray10")) +
  scale_fill_manual(values=c("steelblue1", "maroon2", "seagreen3", "orange")) + 
  theme(legend.position="none")+ stat_boxplot(geom = 'errorbar', width = 0.3)

bp
###save image
Figure1A <- bp
ggsave("Figure1A.png", plot = Figure1A, width = 5.5, height = 4.5, units = "cm", device = "png", dpi = 1200, scale = 1.5)
dev.off()

##### volcano plot

library(ggplot2)
library(ggrepel)
library(EnhancedVolcano)
volcano_Q4.Q1 <- EnhancedVolcano(resLFC.Q4.1,
                lab = resLFC.Q4.1$symbol,
                x = 'log2FoldChange',
                y = 'pvalue',
                xlim = c(-8, 8),
                ylim = c(0, 45),
                title = NULL,
                subtitle = NULL,
                pCutoff = 10e-4,
                FCcutoff = 2,
                cutoffLineType = 'twodash',
                cutoffLineWidth = 0.6,
                pointSize = 1.0,
                labSize = 0,
                #selectLab = NA,
                col=c('black', 'gray', 'steelblue1', 'orange'),
                colAlpha = 1,
                axisLabSize = 18,
                #legendLabSize = 10,
                #legendIconSize = 3,
                legendPosition = 'none',
                borderWidth = 1) 
volcano_Q4.Q1

# save plot
Figure1B <- volcano_Q4.Q1
ggsave("Figure1B.png", plot = Figure1B, width = 8, height = 7, units = "cm", device = "png", dpi = 1200, scale = 2)
dev.off()



  
###----------------- Gene Set Enrichment Analysis using Cluster Profiler-------------------------------###
#Figure 1C-D
  
library(dplyr)
library(AnnotationDbi)
library(org.Hs.eg.db)
columns(org.Hs.eg.db)



#ids = list of IDS
#fromKey = key type; toKey = key type we want to convert to
#db = the AnnotationDb object to use.
#ifMultiple = the argument specifies what to do if one source ID maps to several target IDs:
#should the function return an NA or simply the first of the multiple IDs?
convertIDs <- function( ids, fromKey, toKey, db, ifMultiple=c( "putNA", "useFirst" ) ) {
  stopifnot( inherits( db, "AnnotationDb" ) )
  ifMultiple <- match.arg( ifMultiple )
  suppressWarnings( selRes <- AnnotationDbi::select(
    db, keys=ids, keytype=fromKey, columns=c(fromKey,toKey) ) )
  if( ifMultiple == "putNA" ) {
    duplicatedIds <- selRes[ duplicated( selRes[,1] ), 1 ]  
    selRes <- selRes[ ! selRes[,1] %in% duplicatedIds, ] }
  return( selRes[ match( ids, selRes[,1] ), 2 ] )
}


##Q4 vs. Q1
resLFC.Q4.1$ENSEMBL <- row.names(as.data.frame(resLFC.Q4.1))

#resLFC.Q4.1.2 <- resLFC2
#resLFC.Q4.1.2$ENSEMBL <- row.names(as.data.frame(resLFC.Q4.1))

# #!isUnique(mrna$ENSEMBL) -> nonunique
resLFC.Q4.1$ENSEMBL<- gsub("\\..*","",resLFC.Q4.1$ENSEMBL)
# #!isUnique(mrna$ENSEMBL) -> nonunique
#as.data.frame(resLFC.Q2.)
row.names(resLFC.Q4.1) <- resLFC.Q4.1$ENSEMBL
resLFC.Q4.1$symbol <- convertIDs( row.names(resLFC.Q4.1), "ENSEMBL", "SYMBOL", org.Hs.eg.db )
resLFC.Q4.1$entrezid <- convertIDs( row.names(resLFC.Q4.1), "ENSEMBL", "ENTREZID", org.Hs.eg.db )
head(resLFC.Q4.1, 4)


# set up genes for clusterprofiler analysis
res.final.Q4.1 <- as.data.frame(resLFC.Q4.1) %>% 
  dplyr::select(symbol, log2FoldChange, entrezid, ENSEMBL) %>% 
  na.omit() %>% 
  distinct() %>%
  arrange(desc(log2FoldChange))

resSig.Q4.1 <- as.data.frame(resLFC.Q4.1) %>% 
  dplyr::select(symbol, log2FoldChange, entrezid, ENSEMBL, padj) %>% 
  na.omit() %>% 
  distinct() %>%
  filter(padj < 0.1) %>%
  filter(log2FoldChange > 1 | log2FoldChange < -1) %>%
  arrange(desc(log2FoldChange))
head(resSig.Q4.1)
head(res.final.Q4.1)



library(tibble)
# ranks <- deframe(res4)
# head(ranks, 20)
# summary(res4)
library(clusterProfiler)
library(wordcloud)
organism = "org.Hs.eg.db"
#BiocManager::install(organism, character.only = TRUE)
library(organism, character.only = TRUE)
library(ggplot2)
library(enrichplot)
library(dplyr)
library(cowplot)


## create gene list

 ####### for Q4 vs. Q1
genelist_ensembl.Q4.1 <- res.final.Q4.1$log2FoldChange
genelist_entrezid.Q4.1 <- res.final.Q4.1$log2FoldChange
genelist_symbol.Q4.1 <- res.final.Q4.1$log2FoldChange

# name the vector
names(genelist_ensembl.Q4.1) <- res.final.Q4.1$ENSEMBL
names(genelist_entrezid.Q4.1) <- res.final.Q4.1$entrezid
names(genelist_symbol.Q4.1) <- res.final.Q4.1$symbol


de.Q4.1.1 <- as.data.frame(resSig.Q4.1) %>% 
  dplyr::select(ENSEMBL, log2FoldChange) 
head(de.Q4.1.1)

sig_genes_Q4.1_df.1 <- de.Q4.1.1
# From significant results, we want to filter on log2fold change
siggenesQ4.1.1 <- sig_genes_Q4.1_df.1$log2FoldChange
siggenesQ4.1.1
# Name the vector
names(siggenesQ4.1.1) <- sig_genes_Q4.1_df.1$ENSEMBL
names(siggenesQ4.1.1)

